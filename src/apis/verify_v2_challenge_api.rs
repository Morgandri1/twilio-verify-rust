/*
 * Twilio - Verify
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`create_challenge`]
#[derive(Clone, Debug)]
pub struct CreateChallengeParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// Customer unique identity for the Entity owner of the Challenge. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String,
    /// The unique SID identifier of the Factor.
    pub factor_sid: String,
    /// The date-time when this Challenge expires, given in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format. The default value is five (5) minutes after Challenge creation. The max value is sixty (60) minutes after creation.
    pub expiration_date: Option<String>,
    /// Shown to the user when the push notification arrives. Required when `factor_type` is `push`. Can be up to 256 characters in length
    pub details_message: Option<String>,
    /// A list of objects that describe the Fields included in the Challenge. Each object contains the label and value of the field, the label can be up to 36 characters in length and the value can be up to 128 characters in length. Used when `factor_type` is `push`. There can be up to 20 details fields.
    pub details_fields: Option<Vec<serde_json::Value>>,
    /// Details provided to give context about the Challenge. Not shown to the end user. It must be a stringified JSON with only strings values eg. `{\\\"ip\\\": \\\"172.168.1.234\\\"}`. Can be up to 1024 characters in length
    pub hidden_details: Option<models::serde_json::Value>,
    /// Optional payload used to verify the Challenge upon creation. Only used with a Factor of type `totp` to carry the TOTP code that needs to be verified. For `TOTP` this value must be between 3 and 8 characters long.
    pub auth_payload: Option<String>
}

/// struct for passing parameters to the method [`fetch_challenge`]
#[derive(Clone, Debug)]
pub struct FetchChallengeParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// Customer unique identity for the Entity owner of the Challenges. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String,
    /// A 34 character string that uniquely identifies this Challenge.
    pub sid: String
}

/// struct for passing parameters to the method [`list_challenge`]
#[derive(Clone, Debug)]
pub struct ListChallengeParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// Customer unique identity for the Entity owner of the Challenge. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String,
    /// The unique SID identifier of the Factor.
    pub factor_sid: Option<String>,
    /// The Status of the Challenges to fetch. One of `pending`, `expired`, `approved` or `denied`.
    pub status: Option<models::ChallengeEnumChallengeStatuses>,
    /// The desired sort order of the Challenges list. One of `asc` or `desc` for ascending and descending respectively. Defaults to `asc`.
    pub order: Option<models::ChallengeEnumListOrders>,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i64>,
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`update_challenge`]
#[derive(Clone, Debug)]
pub struct UpdateChallengeParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// Customer unique identity for the Entity owner of the Challenge. This identifier should be immutable, not PII, length between 8 and 64 characters, and generated by your external system, such as your user's UUID, GUID, or SID. It can only contain dash (-) separated alphanumeric characters.
    pub identity: String,
    /// A 34 character string that uniquely identifies this Challenge.
    pub sid: String,
    /// The optional payload needed to verify the Challenge. E.g., a TOTP would use the numeric code. For `TOTP` this value must be between 3 and 8 characters long. For `Push` this value can be up to 5456 characters in length
    pub auth_payload: Option<String>,
    /// Custom metadata associated with the challenge. This is added by the Device/SDK directly to allow for the inclusion of device information. It must be a stringified JSON with only strings values eg. `{\\\"os\\\": \\\"Android\\\"}`. Can be up to 1024 characters in length.
    pub metadata: Option<models::serde_json::Value>
}


/// struct for typed errors of method [`create_challenge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChallengeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_challenge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchChallengeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_challenge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListChallengeError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_challenge`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateChallengeError {
    UnknownValue(serde_json::Value),
}


/// Create a new Challenge for the Factor
pub async fn create_challenge(configuration: &configuration::Configuration, params: CreateChallengeParams) -> Result<models::VerifyV2ServiceEntityChallenge, Error<CreateChallengeError>> {

    let uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges", configuration.base_path, ServiceSid=crate::apis::urlencode(params.service_sid), Identity=crate::apis::urlencode(params.identity));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("FactorSid", params.factor_sid.to_string());
    if let Some(param_value) = params.expiration_date {
        multipart_form_params.insert("ExpirationDate", param_value.to_string());
    }
    if let Some(param_value) = params.details_message {
        multipart_form_params.insert("Details.Message", param_value.to_string());
    }
    if let Some(param_value) = params.details_fields {
        multipart_form_params.insert("Details.Fields", param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string());
    }
    if let Some(param_value) = params.hidden_details {
        multipart_form_params.insert("HiddenDetails", param_value.to_string());
    }
    if let Some(param_value) = params.auth_payload {
        multipart_form_params.insert("AuthPayload", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyV2ServiceEntityChallenge`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyV2ServiceEntityChallenge`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateChallengeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch a specific Challenge.
pub async fn fetch_challenge(configuration: &configuration::Configuration, params: FetchChallengeParams) -> Result<models::VerifyV2ServiceEntityChallenge, Error<FetchChallengeError>> {

    let uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{Sid}", configuration.base_path, ServiceSid=crate::apis::urlencode(params.service_sid), Identity=crate::apis::urlencode(params.identity), Sid=crate::apis::urlencode(params.sid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyV2ServiceEntityChallenge`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyV2ServiceEntityChallenge`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchChallengeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a list of all Challenges for a Factor.
pub async fn list_challenge(configuration: &configuration::Configuration, params: ListChallengeParams) -> Result<models::ListChallengeResponse, Error<ListChallengeError>> {

    let uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges", configuration.base_path, ServiceSid=crate::apis::urlencode(params.service_sid), Identity=crate::apis::urlencode(params.identity));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.factor_sid {
        req_builder = req_builder.query(&[("FactorSid", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.status {
        req_builder = req_builder.query(&[("Status", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.order {
        req_builder = req_builder.query(&[("Order", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("Page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListChallengeResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListChallengeResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListChallengeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Verify a specific Challenge.
pub async fn update_challenge(configuration: &configuration::Configuration, params: UpdateChallengeParams) -> Result<models::VerifyV2ServiceEntityChallenge, Error<UpdateChallengeError>> {

    let uri_str = format!("{}/v2/Services/{ServiceSid}/Entities/{Identity}/Challenges/{Sid}", configuration.base_path, ServiceSid=crate::apis::urlencode(params.service_sid), Identity=crate::apis::urlencode(params.identity), Sid=crate::apis::urlencode(params.sid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.auth_payload {
        multipart_form_params.insert("AuthPayload", param_value.to_string());
    }
    if let Some(param_value) = params.metadata {
        multipart_form_params.insert("Metadata", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyV2ServiceEntityChallenge`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyV2ServiceEntityChallenge`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateChallengeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

