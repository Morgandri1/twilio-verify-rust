/*
 * Twilio - Verify
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`create_access_token`]
#[derive(Clone, Debug)]
pub struct CreateAccessTokenParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// The unique external identifier for the Entity of the Service. This identifier should be immutable, not PII, and generated by your external system, such as your user's UUID, GUID, or SID.
    pub identity: String,
    pub factor_type: models::models::AccessTokenEnumFactorTypes,
    /// The friendly name of the factor that is going to be created with this access token
    pub factor_friendly_name: Option<String>,
    /// How long, in seconds, the access token is valid. Can be an integer between 60 and 300. Default is 60.
    pub ttl: Option<i32>
}

/// struct for passing parameters to the method [`fetch_access_token`]
#[derive(Clone, Debug)]
pub struct FetchAccessTokenParams {
    /// The unique SID identifier of the Service.
    pub service_sid: String,
    /// A 34 character string that uniquely identifies this Access Token.
    pub sid: String
}


/// struct for typed errors of method [`create_access_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateAccessTokenError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_access_token`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchAccessTokenError {
    UnknownValue(serde_json::Value),
}


/// Create a new enrollment Access Token for the Entity
pub async fn create_access_token(configuration: &configuration::Configuration, params: CreateAccessTokenParams) -> Result<models::VerifyV2ServiceAccessToken, Error<CreateAccessTokenError>> {

    let uri_str = format!("{}/v2/Services/{ServiceSid}/AccessTokens", configuration.base_path, ServiceSid=crate::apis::urlencode(params.service_sid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("Identity", params.identity.to_string());
    multipart_form_params.insert("FactorType", params.factor_type.to_string());
    if let Some(param_value) = params.factor_friendly_name {
        multipart_form_params.insert("FactorFriendlyName", param_value.to_string());
    }
    if let Some(param_value) = params.ttl {
        multipart_form_params.insert("Ttl", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyV2ServiceAccessToken`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyV2ServiceAccessToken`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateAccessTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch an Access Token for the Entity
pub async fn fetch_access_token(configuration: &configuration::Configuration, params: FetchAccessTokenParams) -> Result<models::VerifyV2ServiceAccessToken, Error<FetchAccessTokenError>> {

    let uri_str = format!("{}/v2/Services/{ServiceSid}/AccessTokens/{Sid}", configuration.base_path, ServiceSid=crate::apis::urlencode(params.service_sid), Sid=crate::apis::urlencode(params.sid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyV2ServiceAccessToken`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyV2ServiceAccessToken`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchAccessTokenError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

