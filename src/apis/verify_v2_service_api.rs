/*
 * Twilio - Verify
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`create_service`]
#[derive(Clone, Debug)]
pub struct CreateServiceParams {
    /// A descriptive string that you create to describe the verification service. It can be up to 32 characters long. **This value should not contain PII.**
    pub friendly_name: String,
    /// The length of the verification code to generate. Must be an integer value between 4 and 10, inclusive.
    pub code_length: Option<i32>,
    /// Whether to perform a lookup with each verification started and return info about the phone number.
    pub lookup_enabled: Option<bool>,
    /// Whether to skip sending SMS verifications to landlines. Requires `lookup_enabled`.
    pub skip_sms_to_landlines: Option<bool>,
    /// Whether to ask the user to press a number before delivering the verify code in a phone call.
    pub dtmf_input_required: Option<bool>,
    /// The name of an alternative text-to-speech service to use in phone calls. Applies only to TTS languages.
    pub tts_name: Option<String>,
    /// Whether to pass PSD2 transaction parameters when starting a verification.
    pub psd2_enabled: Option<bool>,
    /// Whether to add a security warning at the end of an SMS verification body. Disabled by default and applies only to SMS. Example SMS body: `Your AppName verification code is: 1234. Don’t share this code with anyone; our employees will never ask for the code`
    pub do_not_share_warning_enabled: Option<bool>,
    /// Whether to allow sending verifications with a custom code instead of a randomly generated one.
    pub custom_code_enabled: Option<bool>,
    /// Optional configuration for the Push factors. If true, include the date in the Challenge's response. Otherwise, the date is omitted from the response. See [Challenge](https://www.twilio.com/docs/verify/api/challenge) resource’s details parameter for more info. Default: false. **Deprecated** do not use this parameter. This timestamp value is the same one as the one found in `date_created`, please use that one instead.
    pub push_include_date: Option<bool>,
    /// Optional configuration for the Push factors. Set the APN Credential for this service. This will allow to send push notifications to iOS devices. See [Credential Resource](https://www.twilio.com/docs/notify/api/credential-resource)
    pub push_apn_credential_sid: Option<String>,
    /// Optional configuration for the Push factors. Set the FCM Credential for this service. This will allow to send push notifications to Android devices. See [Credential Resource](https://www.twilio.com/docs/notify/api/credential-resource)
    pub push_fcm_credential_sid: Option<String>,
    /// Optional configuration for the TOTP factors. Set TOTP Issuer for this service. This will allow to configure the issuer of the TOTP URI. Defaults to the service friendly name if not provided.
    pub totp_issuer: Option<String>,
    /// Optional configuration for the TOTP factors. Defines how often, in seconds, are TOTP codes generated. i.e, a new TOTP code is generated every time_step seconds. Must be between 20 and 60 seconds, inclusive. Defaults to 30 seconds
    pub totp_time_step: Option<i32>,
    /// Optional configuration for the TOTP factors. Number of digits for generated TOTP codes. Must be between 3 and 8, inclusive. Defaults to 6
    pub totp_code_length: Option<i32>,
    /// Optional configuration for the TOTP factors. The number of time-steps, past and future, that are valid for validation of TOTP codes. Must be between 0 and 2, inclusive. Defaults to 1
    pub totp_skew: Option<i32>,
    /// The default message [template](https://www.twilio.com/docs/verify/api/templates). Will be used for all SMS verifications unless explicitly overriden. SMS channel only.
    pub default_template_sid: Option<String>,
    /// The SID of the Messaging Service containing WhatsApp Sender(s) that Verify will use to send WhatsApp messages to your users.
    pub whatsapp_msg_service_sid: Option<String>,
    /// The number to use as the WhatsApp Sender that Verify will use to send WhatsApp messages to your users.This WhatsApp Sender must be associated with a Messaging Service SID.
    pub whatsapp_from: Option<String>,
    /// The Relying Party ID for Passkeys. This is the domain of your application, e.g. `example.com`. It is used to identify your application when creating Passkeys.
    pub passkeys_relying_party_id: Option<String>,
    /// The Relying Party Name for Passkeys. This is the name of your application, e.g. `Example App`. It is used to identify your application when creating Passkeys.
    pub passkeys_relying_party_name: Option<String>,
    /// The Relying Party Origins for Passkeys. This is the origin of your application, e.g. `login.example.com,www.example.com`. It is used to identify your application when creating Passkeys, it can have multiple origins split by `,`.
    pub passkeys_relying_party_origins: Option<String>,
    /// The Authenticator Attachment for Passkeys. This is the type of authenticator that will be used to create Passkeys. It can be empty or it can have the values `platform`, `cross-platform` or `any`.
    pub passkeys_authenticator_attachment: Option<String>,
    /// Indicates whether credentials must be discoverable by the authenticator. It can be empty or it can have the values `required`, `preferred` or `discouraged`.
    pub passkeys_discoverable_credentials: Option<String>,
    /// The User Verification for Passkeys. This is the type of user verification that will be used to create Passkeys. It can be empty or it can have the values `required`, `preferred` or `discouraged`.
    pub passkeys_user_verification: Option<String>,
    /// Whether to allow verifications from the service to reach the stream-events sinks if configured
    pub verify_event_subscription_enabled: Option<bool>
}

/// struct for passing parameters to the method [`delete_service`]
#[derive(Clone, Debug)]
pub struct DeleteServiceParams {
    /// The Twilio-provided string that uniquely identifies the Verification Service resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_service`]
#[derive(Clone, Debug)]
pub struct FetchServiceParams {
    /// The Twilio-provided string that uniquely identifies the Verification Service resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`list_service`]
#[derive(Clone, Debug)]
pub struct ListServiceParams {
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i64>,
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`update_service`]
#[derive(Clone, Debug)]
pub struct UpdateServiceParams {
    /// The Twilio-provided string that uniquely identifies the Service resource to update.
    pub sid: String,
    /// A descriptive string that you create to describe the verification service. It can be up to 32 characters long. **This value should not contain PII.**
    pub friendly_name: Option<String>,
    /// The length of the verification code to generate. Must be an integer value between 4 and 10, inclusive.
    pub code_length: Option<i32>,
    /// Whether to perform a lookup with each verification started and return info about the phone number.
    pub lookup_enabled: Option<bool>,
    /// Whether to skip sending SMS verifications to landlines. Requires `lookup_enabled`.
    pub skip_sms_to_landlines: Option<bool>,
    /// Whether to ask the user to press a number before delivering the verify code in a phone call.
    pub dtmf_input_required: Option<bool>,
    /// The name of an alternative text-to-speech service to use in phone calls. Applies only to TTS languages.
    pub tts_name: Option<String>,
    /// Whether to pass PSD2 transaction parameters when starting a verification.
    pub psd2_enabled: Option<bool>,
    /// Whether to add a privacy warning at the end of an SMS. **Disabled by default and applies only for SMS.**
    pub do_not_share_warning_enabled: Option<bool>,
    /// Whether to allow sending verifications with a custom code instead of a randomly generated one.
    pub custom_code_enabled: Option<bool>,
    /// Optional configuration for the Push factors. If true, include the date in the Challenge's response. Otherwise, the date is omitted from the response. See [Challenge](https://www.twilio.com/docs/verify/api/challenge) resource’s details parameter for more info. Default: false. **Deprecated** do not use this parameter.
    pub push_include_date: Option<bool>,
    /// Optional configuration for the Push factors. Set the APN Credential for this service. This will allow to send push notifications to iOS devices. See [Credential Resource](https://www.twilio.com/docs/notify/api/credential-resource)
    pub push_apn_credential_sid: Option<String>,
    /// Optional configuration for the Push factors. Set the FCM Credential for this service. This will allow to send push notifications to Android devices. See [Credential Resource](https://www.twilio.com/docs/notify/api/credential-resource)
    pub push_fcm_credential_sid: Option<String>,
    /// Optional configuration for the TOTP factors. Set TOTP Issuer for this service. This will allow to configure the issuer of the TOTP URI.
    pub totp_issuer: Option<String>,
    /// Optional configuration for the TOTP factors. Defines how often, in seconds, are TOTP codes generated. i.e, a new TOTP code is generated every time_step seconds. Must be between 20 and 60 seconds, inclusive. Defaults to 30 seconds
    pub totp_time_step: Option<i32>,
    /// Optional configuration for the TOTP factors. Number of digits for generated TOTP codes. Must be between 3 and 8, inclusive. Defaults to 6
    pub totp_code_length: Option<i32>,
    /// Optional configuration for the TOTP factors. The number of time-steps, past and future, that are valid for validation of TOTP codes. Must be between 0 and 2, inclusive. Defaults to 1
    pub totp_skew: Option<i32>,
    /// The default message [template](https://www.twilio.com/docs/verify/api/templates). Will be used for all SMS verifications unless explicitly overriden. SMS channel only.
    pub default_template_sid: Option<String>,
    /// The SID of the [Messaging Service](https://www.twilio.com/docs/messaging/services) to associate with the Verification Service.
    pub whatsapp_msg_service_sid: Option<String>,
    /// The WhatsApp number to use as the sender of the verification messages. This number must be associated with the WhatsApp Message Service.
    pub whatsapp_from: Option<String>,
    /// The Relying Party ID for Passkeys. This is the domain of your application, e.g. `example.com`. It is used to identify your application when creating Passkeys.
    pub passkeys_relying_party_id: Option<String>,
    /// The Relying Party Name for Passkeys. This is the name of your application, e.g. `Example App`. It is used to identify your application when creating Passkeys.
    pub passkeys_relying_party_name: Option<String>,
    /// The Relying Party Origins for Passkeys. This is the origin of your application, e.g. `login.example.com,www.example.com`. It is used to identify your application when creating Passkeys, it can have multiple origins split by `,`.
    pub passkeys_relying_party_origins: Option<String>,
    /// Whether to allow verifications from the service to reach the stream-events sinks if configured
    pub verify_event_subscription_enabled: Option<bool>
}


/// struct for typed errors of method [`create_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListServiceError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_service`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateServiceError {
    UnknownValue(serde_json::Value),
}


/// Create a new Verification Service.
pub async fn create_service(configuration: &configuration::Configuration, params: CreateServiceParams) -> Result<models::VerifyV2Service, Error<CreateServiceError>> {

    let uri_str = format!("{}/v2/Services", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("FriendlyName", params.friendly_name.to_string());
    if let Some(param_value) = params.code_length {
        multipart_form_params.insert("CodeLength", param_value.to_string());
    }
    if let Some(param_value) = params.lookup_enabled {
        multipart_form_params.insert("LookupEnabled", param_value.to_string());
    }
    if let Some(param_value) = params.skip_sms_to_landlines {
        multipart_form_params.insert("SkipSmsToLandlines", param_value.to_string());
    }
    if let Some(param_value) = params.dtmf_input_required {
        multipart_form_params.insert("DtmfInputRequired", param_value.to_string());
    }
    if let Some(param_value) = params.tts_name {
        multipart_form_params.insert("TtsName", param_value.to_string());
    }
    if let Some(param_value) = params.psd2_enabled {
        multipart_form_params.insert("Psd2Enabled", param_value.to_string());
    }
    if let Some(param_value) = params.do_not_share_warning_enabled {
        multipart_form_params.insert("DoNotShareWarningEnabled", param_value.to_string());
    }
    if let Some(param_value) = params.custom_code_enabled {
        multipart_form_params.insert("CustomCodeEnabled", param_value.to_string());
    }
    if let Some(param_value) = params.push_include_date {
        multipart_form_params.insert("Push.IncludeDate", param_value.to_string());
    }
    if let Some(param_value) = params.push_apn_credential_sid {
        multipart_form_params.insert("Push.ApnCredentialSid", param_value.to_string());
    }
    if let Some(param_value) = params.push_fcm_credential_sid {
        multipart_form_params.insert("Push.FcmCredentialSid", param_value.to_string());
    }
    if let Some(param_value) = params.totp_issuer {
        multipart_form_params.insert("Totp.Issuer", param_value.to_string());
    }
    if let Some(param_value) = params.totp_time_step {
        multipart_form_params.insert("Totp.TimeStep", param_value.to_string());
    }
    if let Some(param_value) = params.totp_code_length {
        multipart_form_params.insert("Totp.CodeLength", param_value.to_string());
    }
    if let Some(param_value) = params.totp_skew {
        multipart_form_params.insert("Totp.Skew", param_value.to_string());
    }
    if let Some(param_value) = params.default_template_sid {
        multipart_form_params.insert("DefaultTemplateSid", param_value.to_string());
    }
    if let Some(param_value) = params.whatsapp_msg_service_sid {
        multipart_form_params.insert("Whatsapp.MsgServiceSid", param_value.to_string());
    }
    if let Some(param_value) = params.whatsapp_from {
        multipart_form_params.insert("Whatsapp.From", param_value.to_string());
    }
    if let Some(param_value) = params.passkeys_relying_party_id {
        multipart_form_params.insert("Passkeys.RelyingParty.Id", param_value.to_string());
    }
    if let Some(param_value) = params.passkeys_relying_party_name {
        multipart_form_params.insert("Passkeys.RelyingParty.Name", param_value.to_string());
    }
    if let Some(param_value) = params.passkeys_relying_party_origins {
        multipart_form_params.insert("Passkeys.RelyingParty.Origins", param_value.to_string());
    }
    if let Some(param_value) = params.passkeys_authenticator_attachment {
        multipart_form_params.insert("Passkeys.AuthenticatorAttachment", param_value.to_string());
    }
    if let Some(param_value) = params.passkeys_discoverable_credentials {
        multipart_form_params.insert("Passkeys.DiscoverableCredentials", param_value.to_string());
    }
    if let Some(param_value) = params.passkeys_user_verification {
        multipart_form_params.insert("Passkeys.UserVerification", param_value.to_string());
    }
    if let Some(param_value) = params.verify_event_subscription_enabled {
        multipart_form_params.insert("VerifyEventSubscriptionEnabled", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyV2Service`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyV2Service`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateServiceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a specific Verification Service Instance.
pub async fn delete_service(configuration: &configuration::Configuration, params: DeleteServiceParams) -> Result<(), Error<DeleteServiceError>> {

    let uri_str = format!("{}/v2/Services/{Sid}", configuration.base_path, Sid=crate::apis::urlencode(params.sid));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteServiceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch specific Verification Service Instance.
pub async fn fetch_service(configuration: &configuration::Configuration, params: FetchServiceParams) -> Result<models::VerifyV2Service, Error<FetchServiceError>> {

    let uri_str = format!("{}/v2/Services/{Sid}", configuration.base_path, Sid=crate::apis::urlencode(params.sid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyV2Service`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyV2Service`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchServiceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a list of all Verification Services for an account.
pub async fn list_service(configuration: &configuration::Configuration, params: ListServiceParams) -> Result<models::ListServiceResponse, Error<ListServiceError>> {

    let uri_str = format!("{}/v2/Services", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("Page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListServiceResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListServiceResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListServiceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a specific Verification Service.
pub async fn update_service(configuration: &configuration::Configuration, params: UpdateServiceParams) -> Result<models::VerifyV2Service, Error<UpdateServiceError>> {

    let uri_str = format!("{}/v2/Services/{Sid}", configuration.base_path, Sid=crate::apis::urlencode(params.sid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.friendly_name {
        multipart_form_params.insert("FriendlyName", param_value.to_string());
    }
    if let Some(param_value) = params.code_length {
        multipart_form_params.insert("CodeLength", param_value.to_string());
    }
    if let Some(param_value) = params.lookup_enabled {
        multipart_form_params.insert("LookupEnabled", param_value.to_string());
    }
    if let Some(param_value) = params.skip_sms_to_landlines {
        multipart_form_params.insert("SkipSmsToLandlines", param_value.to_string());
    }
    if let Some(param_value) = params.dtmf_input_required {
        multipart_form_params.insert("DtmfInputRequired", param_value.to_string());
    }
    if let Some(param_value) = params.tts_name {
        multipart_form_params.insert("TtsName", param_value.to_string());
    }
    if let Some(param_value) = params.psd2_enabled {
        multipart_form_params.insert("Psd2Enabled", param_value.to_string());
    }
    if let Some(param_value) = params.do_not_share_warning_enabled {
        multipart_form_params.insert("DoNotShareWarningEnabled", param_value.to_string());
    }
    if let Some(param_value) = params.custom_code_enabled {
        multipart_form_params.insert("CustomCodeEnabled", param_value.to_string());
    }
    if let Some(param_value) = params.push_include_date {
        multipart_form_params.insert("Push.IncludeDate", param_value.to_string());
    }
    if let Some(param_value) = params.push_apn_credential_sid {
        multipart_form_params.insert("Push.ApnCredentialSid", param_value.to_string());
    }
    if let Some(param_value) = params.push_fcm_credential_sid {
        multipart_form_params.insert("Push.FcmCredentialSid", param_value.to_string());
    }
    if let Some(param_value) = params.totp_issuer {
        multipart_form_params.insert("Totp.Issuer", param_value.to_string());
    }
    if let Some(param_value) = params.totp_time_step {
        multipart_form_params.insert("Totp.TimeStep", param_value.to_string());
    }
    if let Some(param_value) = params.totp_code_length {
        multipart_form_params.insert("Totp.CodeLength", param_value.to_string());
    }
    if let Some(param_value) = params.totp_skew {
        multipart_form_params.insert("Totp.Skew", param_value.to_string());
    }
    if let Some(param_value) = params.default_template_sid {
        multipart_form_params.insert("DefaultTemplateSid", param_value.to_string());
    }
    if let Some(param_value) = params.whatsapp_msg_service_sid {
        multipart_form_params.insert("Whatsapp.MsgServiceSid", param_value.to_string());
    }
    if let Some(param_value) = params.whatsapp_from {
        multipart_form_params.insert("Whatsapp.From", param_value.to_string());
    }
    if let Some(param_value) = params.passkeys_relying_party_id {
        multipart_form_params.insert("Passkeys.RelyingParty.Id", param_value.to_string());
    }
    if let Some(param_value) = params.passkeys_relying_party_name {
        multipart_form_params.insert("Passkeys.RelyingParty.Name", param_value.to_string());
    }
    if let Some(param_value) = params.passkeys_relying_party_origins {
        multipart_form_params.insert("Passkeys.RelyingParty.Origins", param_value.to_string());
    }
    if let Some(param_value) = params.verify_event_subscription_enabled {
        multipart_form_params.insert("VerifyEventSubscriptionEnabled", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VerifyV2Service`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VerifyV2Service`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateServiceError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

